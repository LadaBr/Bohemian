---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by brode.
--- DateTime: 10.02.2022 9:41
---

local _, E = ...
local C = E.CORE
local A = E.EVENTS

C:RegisterEvent('CHAT_MSG_GUILD')
C:RegisterEvent('CHAT_MSG_RAID')
C:RegisterEvent('CHAT_MSG_RAID_LEADER')
C:RegisterEvent('CHAT_MSG_PARTY')
C:RegisterEvent('CHAT_MSG_PARTY_LEADER')
C:RegisterEvent('CHAT_MSG_SYSTEM')
C:RegisterEvent('GET_ITEM_INFO_RECEIVED')

function A:CHAT_MSG_GUILD(...)
    E:ChatBid(...)
end

function A:CHAT_MSG_RAID(...)
    E:ChatBid(...)
end


function A:CHAT_MSG_SYSTEM(...)
    C:OnEvent("PLAYER_ROLL", E:ProcessRoll(...))
end

function A:CHAT_MSG_RAID_LEADER(...)
    E:ChatBid(...)
end

function A:CHAT_MSG_PARTY(...)
    if IsInRaid() then
        return
    end
    E:ChatBid(...)
end

function A:CHAT_MSG_PARTY_LEADER(...)
    if IsInRaid() then
        return
    end
    E:ChatBid(...)
end

function A:START_AUCTION(owner, itemId, quantity, price, auctionId, minBid)
    E:Debug("Started auction", owner, itemId, quantity, price, auctionId)
    E.currentItem = {
        id = tonumber(itemId),
        owner = owner,
        quantity = quantity,
        price = price,
        auctionId = auctionId,
        minBid = tonumber(minBid),
        initPrice = price,
        channel = E:GetBroadcastChannel()
    }
    local itemName, _, itemRarity, _, _, _, _, _, _, itemTexture, _ = GetItemInfo(E.currentItem.id)
    if not itemName then
        E.waitForItemInfo = true
        return
    else
        E:LoadAuctionData(itemId, quantity, price, itemName, itemRarity, itemTexture)
    end
    A:BID_COOLDOWN_END(auctionId)
end

function A:GET_ITEM_INFO_RECEIVED(itemId, success)
    if E.waitForItemInfo and success and itemId == E.currentItem.id then
        E.waitForItemInfo = false
        local itemName, _, itemRarity, _, _, _, _, _, _, itemTexture, _ = GetItemInfo(itemId)
        E:LoadAuctionData(itemId,  E.currentItem.quantity,  E.currentItem.price, itemName, itemRarity, itemTexture)
    end
end

function A:BID(value, sender, auctionId)
    if not E.currentItem or auctionId ~= E.currentItem.auctionId then
        E:Debug("Ignoring event. Auction has ended...")
        return
    end
    E:Debug("Bid accepted from", sender, value)
    _G["AuctionItemPriceValue"]:SetText(value)
    value = tonumber(value)
    E:SetHighestBidder(sender, value)
    E:SetCurrentDKPValue(E:GetCurrentDKP() - value)
    local bidValue = _G["BidValue"]
    if not bidValue.isChanged then
        bidValue:SetText(Bohemian_AuctionConfig.addToCurrentAmount and E.currentItem.minBid or value + E.currentItem.minBid)
    end

    if sender == C:GetPlayerName(true) and E:GetCurrentDKP() == value then
        E.currentItem.allIn = true
    end
    E:UpdatePassButtonState()
end

function A:PASS_REQUEST(auctionId, sender)
    if not E.currentItem or auctionId ~= E.currentItem.auctionId then
        E:Debug("Ignoring event. Auction has ended...")
        return
    end
    E:Debug("Pass request from", sender, amount, "I am auction owner:", E:IsPlayerAuctionOwner())
    if not E:IsPlayerAuctionOwner() then
        E:Debug("Skipping because I am not loot master")
        return
    end
    if E.bidHistory[sender] == E.currentItem.price then
        E:Debug("Request ignored.", sender, "is the highest bidder.")
        return
    end
    E.bidHistory[sender] = nil
    E.passedHistory[sender] = true
    E:ValidateBidderDKP()
end



function A:BID_REQUEST(amount, auctionId, isChat, sender)
    if not E.currentItem or auctionId ~= E.currentItem.auctionId then
        E:Debug("Ignoring event. Auction has ended...")
        return
    end
    E:Debug("Bid request from", sender, amount, "I am auction owner:", E:IsPlayerAuctionOwner())
    amount = tonumber(amount)
    -- amount = BohemkaDKP:roundWhole(amount, 10)
    amount = amount - amount % E.currentItem.minBid
    if not E:IsPlayerAuctionOwner() or E.isBidOnCooldown then
        E:Debug("Skipping because I am not loot master")
        return
    end
    if E.bidInfo.name and amount < Bohemian_AuctionConfig.minBid then
        return
    end
    if E.bidInfo.name == sender then
        E:Debug("Ignored because request comes from highest bidder")
        return
    end
    if E.passedHistory[sender] then
        E:Debug("Ignored because request comes from someone who passed")
        return
    end
    local price = tonumber(_G["AuctionItemPriceValue"]:GetText())
    local newBid = price + amount
    local senderCurrentDKP = E:GetCurrentDKP(sender)
    E:Debug("Checking his current DKP", senderCurrentDKP)
    newBid = math.min(senderCurrentDKP, newBid)
    if E.bidInfo.name and (newBid <= E.bidInfo.value and (newBid ~= E.bidInfo.value or senderCurrentDKP ~= newBid)) then
        E:Debug("Ignored because value is too low", newBid , "<=", EE.bidInfo.value)
        return
    end

    if newBid < E.currentItem.minBid then
        return
    end

    if E.bidHistory[sender] and E.bidHistory[sender] == senderCurrentDKP then
        return
    end

    E.currentItem.price = newBid
    E.isBidOnCooldown = true
    C_Timer.After(Bohemian_AuctionConfig.bidCooldown, function ()
        E.isBidOnCooldown = false
        C:SendPriorityEvent(E:GetBroadcastChannel(), E.EVENT.BID_COOLDOWN_END, auctionId)
    end)
    if E.countdownActive then
        E:CancelAuctionCountdown()
    end
    C:SendPriorityEvent(E:GetBroadcastChannel(), E.EVENT.BID, newBid, sender, E.currentItem.auctionId)
    if Bohemian_AuctionConfig.showBidInfoInChat and tonumber(isChat) == 0 then
        SendChatMessage(format("%s bid %d DKP", strsplit("-", sender), E.currentItem.price), E.currentItem.channel)
    end
    E.bidHistory[sender] = newBid
    E:UpdateBidderTable()
end

function A:BID_COOLDOWN_END(auctionId)
    if not E.currentItem or auctionId ~= E.currentItem.auctionId then
        E:Debug("Ignoring event. Auction has ended...")
        return
    end
    E:UpdateBidButtonState()
end

function A:END_AUCTION(auctionId, _, _)
    if not E.currentItem or auctionId ~= E.currentItem.auctionId then
        E:Debug("Ignoring event. Auction has ended...")
        return
    end
    E:LoadDefaults()
    E:UpdateBidderTable()
    E.frames.auction.lootMasterFrame:Hide()
    E.frames.auction:Hide()
    A:ROLL_MODE_END()
end

function A:DELAYED_AUCTION_END(delay)
    E.frames.auction.statusBar.parent:Show()
    E.frames.auction.statusBar:SetMinMaxValues(0, delay)
    E.frames.auction.statusBar:SetValue(delay)
    local max = delay
    E.frames.auction.statusBar:SetScript("OnUpdate", function(self, elapsed)
        if delay > 0 and not E.cancelCountdown then
            delay = delay - elapsed
            self:SetValue(delay)
            self.font:SetText(math.floor(delay+0.5))
            local color = E:GetTimerColor(delay, max)
            if color then
                self:SetStatusBarColor(color.r, color.g, color.b)
            end
        else
            self:SetScript("OnUpdate", nil)
            self.parent:Hide()
            E.cancelCountdown = false
            if delay <= 0 and E:IsPlayerAuctionOwner() then
                E:EndAuction(true)
                E.countdownActive = false
            end
        end
    end)
end

function A:END_AUCTION_COUNTDOWN(auctionId, countdown)
    if not E.currentItem or auctionId ~= self.currentItem.auctionId then
        E:Debug("Ignoring event. Auction has ended...")
        return
    end
    A:DELAYED_AUCTION_END(tonumber(countdown))
end

function A:END_AUCTION_COUNTDOWN_CANCEL(auctionId)
    if not E.currentItem or auctionId ~= E.currentItem.auctionId then
        E:Debug("Ignoring event. Auction has ended...")
        return
    end
    E.cancelCountdown = true
end

function A:INVALIDATE_HIGHEST_BID(auctionId, name, value, sender)
    if not E.currentItem or auctionId ~= E.currentItem.auctionId then
        E:Debug("Ignoring event. Auction has ended...")
        return
    end
    if not sender then
        sender = name
        name = nil
    end
    E:SetHighestBidder(name, tonumber(value))
    _G["AuctionItemPriceValue"]:SetText(value or E.currentItem.initPrice)
end

function A:AUCTION_JOIN(sender, channel)
    if not E.currentItem or not E:IsPlayerAuctionOwner() or channel ~= E.currentItem.channel then
        return
    end
    C:SendPriorityEventTo(sender, E.EVENT.AUCTION_JOIN_RESPONSE, table.toString(E.currentItem), table.toString(E.bidInfo))
end

function A:AUCTION_JOIN_RESPONSE(currentItem, bidInfo)
    currentItem = table.fromString(currentItem)
    bidInfo = table.fromString(bidInfo)
    A:START_AUCTION(currentItem.owner, currentItem.id, currentItem.quantity, currentItem.price, currentItem.auctionId, currentItem.minBid)
    if bidInfo.value then
        A:BID(bidInfo.value, bidInfo.name, currentItem.auctionId)
    end
    E:UpdateBidButtonState()
end

function A:PLAYER_ENTERING_WORLD(isLogin, isReload)
    if not isLogin and not isReload then
        return
    end
    if IsInGuild() then
        E:JoinExistingAuction()
    end
end

function A:ROLL_MODE_START()
    E.isRollMode = true
    E.hasRolled = false
    ButtonAuctionMode:SetAlpha(1)
    BidButton:Hide()
    ButtonPass:Hide()
    BidValue:Hide()
    BidderNameHeader2:Hide()
    BidderNameHeader3:SetText("Roll")
    RollButton:Show()
    RollButton:Enable()
    E.frames.auction.item.priceValue:SetText("")
    E.frames.auction.currentDKPValue:SetText("")
    --BohemkaDKPAuctionFrameArrow:Hide()
    AuctionFrameItemPrice:SetText("Roll:")
    E.frames.auction.item.priceValue:SetText("-")
    E.frames.auction.totalDKPValue:SetText("")
    E.frames.auction.currentDKPValue:SetFontObject("GameFontHighlight")
    E.rollHistory = {}
    E.rollInfo = {}
    E.highestRoll = 0
    E:UpdateBidderTable()
    E:SetHighestBidder(nil)
end

function A:ROLL_MODE_END()
    E.isRollMode = false
    ButtonAuctionMode:SetAlpha(0.3)
    BidButton:Show()
    BidValue:Show()
    BidderNameHeader2:Show()
    BidderNameHeader3:SetText("DKP")
    ButtonPass:Show()
    RollButton:Hide()
    RollButton:Disable()
    E.frames.auction.currentDKPValue:SetText("")
    E.frames.auction.currentDKPValue:SetFontObject("GameFontHighlight")
    E.frames.auction.item.priceValue:SetText("")
    --BohemkaDKPAuctionFrameArrow:Show()
    E:RefreshTotalDKP()
    AuctionFrameItemPrice:SetText("Price:")
    E.rollHistory = {}
    E.rollInfo = {}
    E.highestRoll = 0
    if E.currentItem then
        E.frames.auction.item.priceValue:SetText(E.currentItem.price)
        local bidInfo = E.bidInfo
        E.bidInfo = {}
        if bidInfo.value then
            A:BID(bidInfo.value, bidInfo.name, E.currentItem.auctionId)
        else
            E:SetHighestBidder(nil)
        end
        E:UpdateBidderTable()
    end
end

function A:PLAYER_ROLL(name, roll, low, high)
    if not E.isRollMode or not E.currentItem or low ~= 1 or high ~= 100 then
        return
    end
    if not string.find(name, "-") then
        name = name.."-"..GetNormalizedRealmName()
    end
    E.rollHistory[name] = roll
    if E.highestRoll < roll then
        E.highestRoll = roll
        E:SetHighestBidder(name, roll)
    end
    if name == C:GetPlayerName(true) then
        local font = E:GetFontFromRollValue(roll)
        E.frames.auction.totalDKPValue:SetText("You rolled")
        E.frames.auction.currentDKPValue:SetFontObject(font)
        E.frames.auction.currentDKPValue:SetText(roll)
        RollButton:Disable()
    end
    E:UpdateBidderTable()

    E.frames.auction.item.priceValue:SetText(E.highestRoll)
end

function A:DKP_CHANGED(_, fullName)
    if fullName == C:GetPlayerName(true) then
        E:RefreshTotalDKP()
        self:UpdatePassButtonState()
        self:UpdateBidButtonState()
    end
end
